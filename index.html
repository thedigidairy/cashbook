<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cash Book</title>
  <style>
    :root {
      --bg: #f2f2f2;
      --card: #ffffff;
      --text: #222222;
      --muted: #555555;
      --border: #d9d9d9;
      --accent: #2b6cb0;
      --income: #2f855a;
      --expense: #c53030;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: Arial, Helvetica, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.4;
      font-size: 18px;
    }

    .container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 24px 16px 40px;
    }

    h1 {
      text-align: center;
      margin-bottom: 16px;
      font-size: 32px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 18px;
      margin-bottom: 20px;
    }

    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      align-items: end;
    }

    label {
      display: block;
      font-weight: bold;
      margin-bottom: 6px;
      font-size: 16px;
    }

    @keyframes labelVoiceBlink {
      0% { color: var(--text); }
      50% { color: var(--accent); }
      100% { color: var(--text); }
    }

    input,
    select,
    button {
      width: 100%;
      padding: 10px 12px;
      font-size: 18px;
      border-radius: 6px;
      border: 1px solid var(--border);
    }

    input:focus,
    select:focus,
    button:focus {
      outline: 3px solid rgba(43, 108, 176, 0.2);
      outline-offset: 1px;
    }

    button {
      background: var(--accent);
      color: #fff;
      font-weight: bold;
      border: none;
      cursor: pointer;
    }

    button:hover {
      background: #245c98;
    }

    .totals {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      font-weight: bold;
      font-size: 20px;
    }

    .totals span {
      display: block;
      font-size: 16px;
      font-weight: normal;
      color: var(--muted);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 16px;
    }

    th,
    td {
      border: 1px solid var(--border);
      padding: 10px;
      text-align: left;
    }

    th {
      background: #f8f8f8;
      font-size: 17px;
    }

    .amount-income {
      color: var(--income);
      font-weight: bold;
    }

    .amount-expense {
      color: var(--expense);
      font-weight: bold;
    }

    .balance-positive {
      color: var(--income);
      font-weight: bold;
    }

    .balance-negative {
      color: var(--expense);
      font-weight: bold;
    }

    .empty-state {
      text-align: center;
      color: var(--muted);
      padding: 12px;
    }

    .voice-button {
      padding: 8px 10px;
      font-size: 16px;
    }

    @keyframes voiceGlow {
      0% {
        box-shadow: 0 0 0 0 rgba(43, 108, 176, 0.1);
        border-color: var(--border);
      }

      50% {
        box-shadow: 0 0 0 4px rgba(43, 108, 176, 0.25);
        border-color: var(--accent);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(43, 108, 176, 0.1);
        border-color: var(--border);
      }
    }

    .voice-highlight {
      animation: labelVoiceBlink 0.5s ease-in-out 3;
    }

    .voice-active-field {
      border-color: var(--accent) !important;
      box-shadow: 0 0 0 2px rgba(43, 108, 176, 0.2);
    }

    .voice-listening-field {
      animation: voiceGlow 0.7s ease-in-out infinite;
    }

    @media (max-width: 600px) {
      body {
        font-size: 16px;
      }

      h1 {
        font-size: 26px;
      }

      .totals {
        font-size: 18px;
      }

      table {
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Cash Book</h1>

    <div class="card">
      <form id="entry-form" class="form-grid">
        <div>
          <label for="entry-date" id="label-date">Date</label>
          <input type="date" id="entry-date" required />
        </div>
        <div>
          <label for="entry-desc" id="label-desc">Description / Note</label>
          <input type="text" id="entry-desc" placeholder="e.g., Groceries" required />
        </div>
        <div>
          <label for="entry-amount" id="label-amount">Amount</label>
          <input type="number" id="entry-amount" min="0" step="0.01" placeholder="0.00" required />
        </div>
        <div>
          <label for="entry-type" id="label-type">Type</label>
          <select id="entry-type" required>
            <option value="income" id="type-income-option">Income</option>
            <option value="expense" id="type-expense-option">Expense</option>
          </select>
        </div>
        <div>
          <button type="submit" id="submit-button">Save Entry</button>
        </div>
        <div>
          <button type="button" id="voice-input-button" class="voice-button">ðŸŽ¤ Voice Input</button>
        </div>
      </form>
    </div>

    <div class="card totals" id="totals">
      <div>
        <span id="label-total-income-text">Total Income</span> (â‚¹)
        <span id="total-income">â‚¹0</span>
      </div>
      <div>
        <span id="label-total-expense-text">Total Expense</span> (â‚¹)
        <span id="total-expense">â‚¹0</span>
      </div>
      <div>
        <span id="label-current-balance-text">Current Balance</span> (â‚¹)
        <span id="current-balance">â‚¹0</span>
      </div>
    </div>

    <div class="card">
      <table aria-label="Cash book entries">
        <thead>
          <tr>
            <th>Date</th>
            <th>Description</th>
            <th>Income (â‚¹)</th>
            <th>Expense (â‚¹)</th>
            <th>Running Balance (â‚¹)</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="entries-body"></tbody>
      </table>
      <div id="empty-state" class="empty-state">No entries yet. Add your first entry above.</div>
    </div>
  </div>

  <script>
    const STORAGE_KEY = "cashbookEntries";
    const form = document.getElementById("entry-form");
    const dateInput = document.getElementById("entry-date");
    const descInput = document.getElementById("entry-desc");
    const amountInput = document.getElementById("entry-amount");
    const typeInput = document.getElementById("entry-type");
    const entriesBody = document.getElementById("entries-body");
    const emptyState = document.getElementById("empty-state");
    const submitButton = document.getElementById("submit-button");
    const dateLabel = document.getElementById("label-date");
    const descLabel = document.getElementById("label-desc");
    const amountLabel = document.getElementById("label-amount");
    const typeLabel = document.getElementById("label-type");
    const totalIncomeEl = document.getElementById("total-income");
    const totalExpenseEl = document.getElementById("total-expense");
    const currentBalanceEl = document.getElementById("current-balance");
    const voiceInputButton = document.getElementById("voice-input-button");
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let editIndex = null;
    let recognition = null;
    let isVoiceListening = false;
    let activeVoiceField = "amount";
    let voiceFillTimeout = null;

    const DECIMAL_WORDS = ["point", "dot", "decimal"];

    const EN_NUMBER_WORDS = {
      zero: 0, one: 1, two: 2, three: 3, four: 4, five: 5, six: 6, seven: 7, eight: 8, nine: 9,
      ten: 10, eleven: 11, twelve: 12, thirteen: 13, fourteen: 14, fifteen: 15, sixteen: 16,
      seventeen: 17, eighteen: 18, nineteen: 19, twenty: 20, thirty: 30, forty: 40, fifty: 50,
      sixty: 60, seventy: 70, eighty: 80, ninety: 90,
      naught: 0, oh: 0,
    };

    const TE_NUMBER_WORDS = {
      "à°¸à±à°¨à±à°¨à°¾": 0, "à°’à°•à°Ÿà°¿": 1, "à°’à°•à±à°•à°Ÿà°¿": 1, "à°°à±†à°‚à°¡à±": 2, "à°®à±‚à°¡à±": 3, "à°¨à°¾à°²à±à°—à±": 4,
      "à°à°¦à±": 5, "à°†à°°à±": 6, "à°à°¡à±": 7, "à°Žà°¨à°¿à°®à°¿à°¦à°¿": 8, "à°¤à±Šà°®à±à°®à°¿à°¦à°¿": 9, "à°ªà°¦à°¿": 10,
      "à°ªà°¦à°•à±Šà°‚à°¡à±": 11, "à°ªà°¨à±à°¨à±†à°‚à°¡à±": 12, "à°ªà°¦à°®à±‚à°¡à±": 13, "à°ªà°¦à±à°¨à°¾à°²à±à°—à±": 14, "à°ªà°¦à°¿à°¹à±‡à°¨à±": 15,
      "à°ªà°¦à°¹à°¾à°°à±": 16, "à°ªà°¦à°¿à°¹à±‡à°¡à±": 17, "à°ªà°¦à±à°¦à±†à°¨à°¿à°®à°¿à°¦à°¿": 18, "à°ªà°‚à°¤à±Šà°®à±à°®à°¿à°¦à°¿": 19,
      "à°‡à°°à°µà±ˆ": 20, "à°®à±à°ªà±à°ªà±ˆ": 30, "à°¨à°²à°­à±ˆ": 40, "à°¯à°¾à°­à±ˆ": 50, "à°…à°°à°µà±ˆ": 60,
      "à°¡à±†à°¬à±à°¬à±ˆ": 70, "à°Žà°¨à°­à±ˆ": 80, "à°¤à±Šà°‚à°­à±ˆ": 90,
    };

    const HI_NUMBER_WORDS = {
      "à¤¶à¥‚à¤¨à¥à¤¯": 0, "à¤œà¥€à¤°à¥‹": 0, "à¤à¤•": 1, "à¤¦à¥‹": 2, "à¤¤à¥€à¤¨": 3, "à¤šà¤¾à¤°": 4, "à¤ªà¤¾à¤‚à¤š": 5,
      "à¤ªà¤¾à¤à¤š": 5, "à¤›à¤¹": 6, "à¤¸à¤¾à¤¤": 7, "à¤†à¤ ": 8, "à¤¨à¥Œ": 9, "à¤¦à¤¸": 10, "à¤—à¥à¤¯à¤¾à¤°à¤¹": 11,
      "à¤¬à¤¾à¤°à¤¹": 12, "à¤¤à¥‡à¤°à¤¹": 13, "à¤šà¥Œà¤¦à¤¹": 14, "à¤ªà¤‚à¤¦à¥à¤°à¤¹": 15, "à¤¸à¥‹à¤²à¤¹": 16, "à¤¸à¤¤à¥à¤°à¤¹": 17,
      "à¤…à¤ à¤¾à¤°à¤¹": 18, "à¤‰à¤¨à¥à¤¨à¥€à¤¸": 19, "à¤¬à¥€à¤¸": 20, "à¤¤à¥€à¤¸": 30, "à¤šà¤¾à¤²à¥€à¤¸": 40, "à¤ªà¤šà¤¾à¤¸": 50,
      "à¤¸à¤¾à¤ ": 60, "à¤¸à¤¤à¥à¤¤à¤°": 70, "à¤…à¤¸à¥à¤¸à¥€": 80, "à¤¨à¤¬à¥à¤¬à¥‡": 90,
      do: 2,
    };


    const ROMAN_NUMBER_WORDS = {
      okati: 1, okkati: 1, rendu: 2, moodu: 3, nalugu: 4, aidu: 5, aaru: 6, edu: 7, enimidi: 8, tommidi: 9,
      padi: 10, iravai: 20, muppai: 30, nalabhai: 40, yabhai: 50, aravai: 60, debbai: 70, enabhai: 80, tombhai: 90,
      do: 2,
    };

    const SCALE_WORDS = {
      hundred: 100,
      "à°µà°‚à°¦": 100,
      "à°µà°‚à°¦à°²à±": 100,
      "à¤¸à¥Œ": 100,
      sau: 100,
      vandha: 100,
      vandalu: 100,
      vandu: 100,
      thousand: 1000,
      "à°µà±†à°¯à±à°¯à°¿": 1000,
      "à¤¹à¤œà¤¾à¤°": 1000,
      lakh: 100000,
      "à°²à°•à±à°·": 100000,
      "à¤²à¤¾à¤–": 100000,
      million: 1000000,
      crore: 10000000,
      "à°•à±‹à°Ÿà°¿": 10000000,
      "à¤•à¤°à¥‹à¤¡à¤¼": 10000000,
      "à¤•à¤°à¥‹à¤¡": 10000000,
    };

    const MONTHS = {
      january: 1, february: 2, march: 3, april: 4, may: 5, june: 6,
      july: 7, august: 8, september: 9, october: 10, november: 11, december: 12,
      jan: 1, feb: 2, mar: 3, apr: 4, jun: 6, jul: 7, aug: 8, sep: 9, sept: 9, oct: 10, nov: 11, dec: 12,
    };

    const moneyFormat = new Intl.NumberFormat("en-IN", {
      style: "currency",
      currency: "INR",
      minimumFractionDigits: 0,
      maximumFractionDigits: 2,
    });

    function formatDateForDisplay(isoDate) {
      if (!isoDate || typeof isoDate !== "string") {
        return "";
      }
      const [year, month, day] = isoDate.split("-");
      if (!year || !month || !day) {
        return isoDate;
      }
      return `${day}-${month}-${year}`;
    }

    function parseAmountToPaise(amountValue) {
      if (typeof amountValue !== "string") {
        return null;
      }
      const trimmed = amountValue.trim();
      if (!trimmed) {
        return null;
      }
      const match = /^\d+(?:\.(\d{0,2}))?$/.exec(trimmed);
      if (!match) {
        return null;
      }
      const [wholePart, fractionPart = ""] = trimmed.split(".");
      const fractionPadded = (fractionPart + "00").slice(0, 2);
      return Number(wholePart) * 100 + Number(fractionPadded);
    }

    function formatMoneyFromPaise(paise) {
      return moneyFormat.format(paise / 100);
    }

    function getEntryPaise(entry) {
      const paise = parseAmountToPaise(String(entry.amount));
      return paise === null ? 0 : paise;
    }

    function loadEntries() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) {
        return [];
      }
      try {
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch (error) {
        return [];
      }
    }

    function saveEntries(entries) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(entries));
    }

    function render(entries) {
      entriesBody.innerHTML = "";
      let runningBalancePaise = 0;
      let totalIncomePaise = 0;
      let totalExpensePaise = 0;

      if (entries.length === 0) {
        emptyState.style.display = "block";
      } else {
        emptyState.style.display = "none";
      }

      entries.forEach((entry, index) => {
        const amountPaise = getEntryPaise(entry);
        if (entry.type === "income") {
          runningBalancePaise += amountPaise;
          totalIncomePaise += amountPaise;
        } else {
          runningBalancePaise -= amountPaise;
          totalExpensePaise += amountPaise;
        }

        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${formatDateForDisplay(entry.date)}</td>
          <td>${entry.description}</td>
          <td class="amount-income">${entry.type === "income" ? formatMoneyFromPaise(amountPaise) : ""}</td>
          <td class="amount-expense">${entry.type === "expense" ? formatMoneyFromPaise(amountPaise) : ""}</td>
          <td class="${runningBalancePaise >= 0 ? "balance-positive" : "balance-negative"}">
            ${formatMoneyFromPaise(runningBalancePaise)}
          </td>
          <td>
            <button type="button" data-action="edit" data-index="${index}">Edit</button>
            <button type="button" data-action="delete" data-index="${index}">Delete</button>
          </td>
        `;
        entriesBody.appendChild(row);
      });

      totalIncomeEl.textContent = formatMoneyFromPaise(totalIncomePaise);
      totalExpenseEl.textContent = formatMoneyFromPaise(totalExpensePaise);
      currentBalanceEl.textContent = formatMoneyFromPaise(runningBalancePaise);
    }

    function setToday() {
      const today = new Date().toISOString().split("T")[0];
      dateInput.value = today;
    }

    function resetForm() {
      editIndex = null;
      submitButton.textContent = "Save Entry";
      form.reset();
      setToday();
      typeInput.value = "income";
    }

    function highlightField(fieldElement) {
      if (!fieldElement) {
        return;
      }
      fieldElement.classList.remove("voice-highlight");
      void fieldElement.offsetWidth;
      fieldElement.classList.add("voice-highlight");
      setTimeout(() => {
        fieldElement.classList.remove("voice-highlight");
      }, 1500);
    }

    const VOICE_FIELD_MAP = {
      date: { input: dateInput, label: dateLabel },
      description: { input: descInput, label: descLabel },
      amount: { input: amountInput, label: amountLabel },
      income: { input: typeInput, label: typeLabel },
      expense: { input: typeInput, label: typeLabel },
    };

    function clearFieldVoiceStyles() {
      Object.values(VOICE_FIELD_MAP).forEach(({ input, label }) => {
        input.classList.remove("voice-active-field", "voice-listening-field");
        label.classList.remove("voice-highlight");
      });
    }

    function setActiveVoiceField(fieldKey) {
      activeVoiceField = Object.prototype.hasOwnProperty.call(VOICE_FIELD_MAP, fieldKey) ? fieldKey : null;
      clearFieldVoiceStyles();

      if (!activeVoiceField) {
        return;
      }

      const activeField = VOICE_FIELD_MAP[activeVoiceField];
      activeField.input.classList.add("voice-active-field");
      activeField.label.classList.add("voice-highlight");
    }

    function markListeningState(active) {
      Object.values(VOICE_FIELD_MAP).forEach(({ input }) => {
        input.classList.remove("voice-listening-field");
      });

      if (!active || !activeVoiceField) {
        return;
      }

      VOICE_FIELD_MAP[activeVoiceField].input.classList.add("voice-listening-field");
    }

    function showVoiceFillFeedback(fieldKey) {
      if (!Object.prototype.hasOwnProperty.call(VOICE_FIELD_MAP, fieldKey)) {
        return;
      }

      markListeningState(false);
      const field = VOICE_FIELD_MAP[fieldKey];
      highlightField(field.label);
      field.input.classList.add("voice-active-field");

      if (voiceFillTimeout) {
        clearTimeout(voiceFillTimeout);
      }

      voiceFillTimeout = setTimeout(() => {
        field.input.classList.remove("voice-active-field");
        if (activeVoiceField === fieldKey) {
          field.input.classList.add("voice-active-field");
        }
      }, 1500);
    }

    function normalizeTextForMatch(input) {
      return input
        .toLowerCase()
        .replace(/[.,/#!$%^&*;:{}=\-_`~()]/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    function parseIndianOrEnglishNumberWords(tokens) {
      let total = 0;
      let current = 0;
      let found = false;

      tokens.forEach((token) => {
        if (/^\d+$/.test(token)) {
          current += Number(token);
          found = true;
          return;
        }

        if (Object.prototype.hasOwnProperty.call(EN_NUMBER_WORDS, token)) {
          current += EN_NUMBER_WORDS[token];
          found = true;
          return;
        }

        if (Object.prototype.hasOwnProperty.call(TE_NUMBER_WORDS, token)) {
          current += TE_NUMBER_WORDS[token];
          found = true;
          return;
        }

        if (Object.prototype.hasOwnProperty.call(HI_NUMBER_WORDS, token)) {
          current += HI_NUMBER_WORDS[token];
          found = true;
          return;
        }

        if (Object.prototype.hasOwnProperty.call(ROMAN_NUMBER_WORDS, token)) {
          current += ROMAN_NUMBER_WORDS[token];
          found = true;
          return;
        }

        if (Object.prototype.hasOwnProperty.call(SCALE_WORDS, token)) {
          const scale = SCALE_WORDS[token];
          found = true;

          if (scale === 100) {
            if (current === 0) {
              current = 1;
            }
            current *= scale;
          } else {
            if (current === 0) {
              current = 1;
            }
            total += current * scale;
            current = 0;
          }
        }
      });

      if (!found) {
        return null;
      }
      return total + current;
    }

    function parseDecimalPart(tokens) {
      let decimalDigits = "";
      let found = false;

      tokens.forEach((token) => {
        if (/^\d+$/.test(token)) {
          decimalDigits += token;
          found = true;
          return;
        }

        if (Object.prototype.hasOwnProperty.call(EN_NUMBER_WORDS, token) && EN_NUMBER_WORDS[token] < 10) {
          decimalDigits += String(EN_NUMBER_WORDS[token]);
          found = true;
          return;
        }

        if (Object.prototype.hasOwnProperty.call(TE_NUMBER_WORDS, token) && TE_NUMBER_WORDS[token] < 10) {
          decimalDigits += String(TE_NUMBER_WORDS[token]);
          found = true;
          return;
        }

        if (Object.prototype.hasOwnProperty.call(HI_NUMBER_WORDS, token) && HI_NUMBER_WORDS[token] < 10) {
          decimalDigits += String(HI_NUMBER_WORDS[token]);
          found = true;
          return;
        }

        if (Object.prototype.hasOwnProperty.call(ROMAN_NUMBER_WORDS, token) && ROMAN_NUMBER_WORDS[token] < 10) {
          decimalDigits += String(ROMAN_NUMBER_WORDS[token]);
          found = true;
        }
      });

      if (!found) {
        return "";
      }
      return decimalDigits;
    }

    function parseSpokenAmount(text) {
      if (!text) {
        return null;
      }

      const digitWords = {
        zero: "0", one: "1", two: "2", three: "3", four: "4",
        five: "5", six: "6", seven: "7", eight: "8", nine: "9",
        naught: "0", oh: "0",
      };

      const units = [
        { word: "crore", multiplier: 10000000 },
        { word: "lakh", multiplier: 100000 },
        { word: "thousand", multiplier: 1000 },
      ];

      const parseNumberChunk = (tokens) => {
        if (!tokens.length) {
          return null;
        }

        if (tokens.every((token) => /^\d$/.test(token))) {
          return Number(tokens.join(""));
        }

        if (tokens.length === 1 && /^\d+$/.test(tokens[0])) {
          return Number(tokens[0]);
        }

        let value = 0;
        for (const token of tokens) {
          if (/^\d+$/.test(token)) {
            value += Number(token);
            continue;
          }

          if (token === "hundred") {
            if (value === 0) {
              value = 1;
            }
            value *= 100;
            continue;
          }

          if (!Object.prototype.hasOwnProperty.call(EN_NUMBER_WORDS, token)) {
            return null;
          }

          value += EN_NUMBER_WORDS[token];
        }

        return Number.isFinite(value) ? value : null;
      };

      const parseDecimalChunk = (tokens) => {
        if (!tokens.length) {
          return null;
        }

        let digits = "";
        for (const token of tokens) {
          if (/^\d+$/.test(token)) {
            digits += token;
            continue;
          }

          if (Object.prototype.hasOwnProperty.call(digitWords, token)) {
            digits += digitWords[token];
            continue;
          }

          if (Object.prototype.hasOwnProperty.call(EN_NUMBER_WORDS, token) && EN_NUMBER_WORDS[token] < 10) {
            digits += String(EN_NUMBER_WORDS[token]);
            continue;
          }

          return null;
        }

        return digits || null;
      };

      const cleaned = normalizeTextForMatch(text)
        .replace(/\b(and|rupees?)\b/g, " ")
        .replace(new RegExp(`\\b(${DECIMAL_WORDS.join("|")})\\b`, "g"), " . ")
        .replace(/\s+/g, " ")
        .trim();

      if (!cleaned) {
        return null;
      }

      const tokens = cleaned.split(" ").filter(Boolean);
      const decimalMarkers = tokens.filter((token) => token === ".").length;
      if (decimalMarkers > 1) {
        return null;
      }

      let integerTokens = tokens;
      let decimalTokens = [];

      if (decimalMarkers === 1) {
        const markerIndex = tokens.indexOf(".");
        integerTokens = tokens.slice(0, markerIndex);
        decimalTokens = tokens.slice(markerIndex + 1);

        if (!integerTokens.length || !decimalTokens.length) {
          return null;
        }
      }

      let integerValue = null;

      if (integerTokens.every((token) => /^\d$/.test(token))) {
        integerValue = Number(integerTokens.join(""));
      } else {
        let total = 0;
        let cursor = 0;

        for (const unit of units) {
          const unitIndex = integerTokens.indexOf(unit.word, cursor);
          if (unitIndex === -1) {
            continue;
          }

          const beforeUnit = integerTokens.slice(cursor, unitIndex);
          const chunkValue = parseNumberChunk(beforeUnit);
          if (chunkValue === null) {
            return null;
          }

          total += chunkValue * unit.multiplier;
          cursor = unitIndex + 1;
        }

        const remaining = integerTokens.slice(cursor);
        if (remaining.some((token) => units.some((unit) => unit.word === token))) {
          return null;
        }

        if (remaining.length) {
          const remainingValue = parseNumberChunk(remaining);
          if (remainingValue === null) {
            return null;
          }
          total += remainingValue;
        }

        integerValue = total;
      }

      if (integerValue === null || !Number.isFinite(integerValue)) {
        return null;
      }

      if (!decimalTokens.length) {
        return integerValue;
      }

      const decimalDigits = parseDecimalChunk(decimalTokens);
      if (!decimalDigits) {
        return null;
      }

      const parsed = Number(`${integerValue}.${decimalDigits}`);
      return Number.isFinite(parsed) ? parsed : null;
    }

    function normalizeSpokenDate(spokenDate) {
      if (!spokenDate) {
        return "";
      }

      const cleaned = spokenDate
        .toLowerCase()
        .replace(/(st|nd|rd|th)\b/g, "")
        .replace(/,/g, " ")
        .replace(/\s+/g, " ")
        .trim();

      const monthMatch = cleaned.split(" ").find((part) => MONTHS[part]);
      if (monthMatch) {
        const nums = cleaned.match(/\d+/g) || [];
        if (nums.length >= 2) {
          const day = Number(nums[0]);
          const year = nums.length > 2 ? Number(nums[2]) : Number(nums[1]);
          const month = MONTHS[monthMatch];
          const fullYear = year < 100 ? year + 2000 : year;
          const dateObj = new Date(fullYear, month - 1, day);
          if (!Number.isNaN(dateObj.getTime()) && dateObj.getDate() === day && dateObj.getMonth() === month - 1) {
            return `${fullYear}-${String(month).padStart(2, "0")}-${String(day).padStart(2, "0")}`;
          }
        }
      }

      const directDate = new Date(cleaned);
      if (!Number.isNaN(directDate.getTime())) {
        const y = directDate.getFullYear();
        const m = String(directDate.getMonth() + 1).padStart(2, "0");
        const d = String(directDate.getDate()).padStart(2, "0");
        return `${y}-${m}-${d}`;
      }

      const parts = cleaned.match(/\d+/g);
      if (!parts || parts.length < 3) {
        return "";
      }

      let day = Number(parts[0]);
      let month = Number(parts[1]);
      let year = Number(parts[2]);

      if (parts[0].length === 4) {
        year = Number(parts[0]);
        month = Number(parts[1]);
        day = Number(parts[2]);
      }

      if (year < 100) {
        year += 2000;
      }

      if (month < 1 || month > 12 || day < 1 || day > 31) {
        return "";
      }

      const parsedDate = new Date(year, month - 1, day);
      if (
        parsedDate.getFullYear() !== year ||
        parsedDate.getMonth() !== month - 1 ||
        parsedDate.getDate() !== day
      ) {
        return "";
      }

      return `${year}-${String(month).padStart(2, "0")}-${String(day).padStart(2, "0")}`;
    }

    function detectCommand(text) {
      const rawText = (text || "").trim();
      const loweredText = rawText.toLowerCase();
      const paddedText = ` ${loweredText}`;

      if (loweredText.startsWith("date ")) {
        return { command: "date", value: rawText.slice(5).trim() };
      }

      if (loweredText.startsWith("description ")) {
        return { command: "description", value: rawText.slice(12).trim() };
      }

      if (loweredText.startsWith("amount ")) {
        return { command: "amount", value: rawText.slice(7).trim() };
      }

      if (paddedText.includes(" income")) {
        return { command: "income", value: rawText.replace(/\bincome\b/gi, "").trim() };
      }

      if (paddedText.includes(" expense")) {
        return { command: "expense", value: rawText.replace(/\bexpense\b/gi, "").trim() };
      }

      return { command: null, value: rawText };
    }

    function applyVoiceCommand(transcript) {
      const spokenText = (transcript || "").trim();
      if (!spokenText) {
        return;
      }

      const { command, value } = detectCommand(spokenText);

      if (command === "date") {
        const normalizedDate = normalizeSpokenDate(value);
        if (!normalizedDate) {
          return;
        }
        dateInput.value = normalizedDate;
        setActiveVoiceField("date");
        showVoiceFillFeedback("date");
        return;
      }

      if (command === "description") {
        if (!value) {
          return;
        }
        descInput.value = value;
        setActiveVoiceField("description");
        showVoiceFillFeedback("description");
        return;
      }

      if (command === "amount") {
        const parsedAmount = parseSpokenAmount(value);
        if (parsedAmount === null) {
          return;
        }
        amountInput.value = String(parsedAmount);
        setActiveVoiceField("amount");
        showVoiceFillFeedback("amount");
        return;
      }

      if (command === "income" || command === "expense") {
        typeInput.value = command;
        setActiveVoiceField(command);
        showVoiceFillFeedback(command);
      }
    }

    function updateVoiceButtonText() {
      voiceInputButton.textContent = "ðŸŽ¤ Voice Input";
    }

    function setupVoiceInput() {
      if (!SpeechRecognition) {
        voiceInputButton.addEventListener("click", () => {
          alert("Voice input is not supported in this browser. Please enter details manually.");
        });
        return;
      }

      recognition = new SpeechRecognition();
      recognition.lang = "en-IN";
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;
      recognition.continuous = false;

      recognition.addEventListener("result", (event) => {
        const latest = event.results[event.results.length - 1];
        if (!latest || !latest[0] || !latest[0].transcript) {
          return;
        }
        applyVoiceCommand(latest[0].transcript);
      });

      recognition.addEventListener("start", () => {
        isVoiceListening = true;
        setActiveVoiceField(null);
        markListeningState(true);
      });

      recognition.addEventListener("end", () => {
        isVoiceListening = false;
        markListeningState(false);
        updateVoiceButtonText();
      });

      recognition.addEventListener("error", () => {
        isVoiceListening = false;
        markListeningState(false);
        updateVoiceButtonText();
      });

      voiceInputButton.addEventListener("click", () => {
        if (isVoiceListening) {
          recognition.stop();
          return;
        }
        try {
          recognition.lang = "en-IN";
          recognition.start();
        } catch (error) {
          // Ignore repeated start calls.
        }
      });

      setActiveVoiceField(null);
      updateVoiceButtonText();
    }

    form.addEventListener("submit", (event) => {
      event.preventDefault();

      const date = dateInput.value.trim();
      const description = descInput.value.trim();
      const amountValue = amountInput.value;
      const type = typeInput.value;

      if (!date || !description || !amountValue) {
        alert("Please fill out date, description, and amount.");
        return;
      }

      const amountPaise = parseAmountToPaise(amountValue);
      if (amountPaise === null || amountPaise <= 0) {
        alert("Please enter a valid amount greater than zero.");
        return;
      }

      const entries = loadEntries();
      const entryPayload = {
        date,
        description,
        amount: amountValue,
        type,
      };

      if (editIndex === null) {
        entries.push(entryPayload);
      } else {
        entries[editIndex] = entryPayload;
      }
      saveEntries(entries);
      render(entries);

      resetForm();
      descInput.focus();
    });

    entriesBody.addEventListener("click", (event) => {
      const button = event.target.closest("button");
      if (!button) {
        return;
      }

      const action = button.dataset.action;
      const index = Number(button.dataset.index);
      if (Number.isNaN(index)) {
        return;
      }

      const entries = loadEntries();
      if (!entries[index]) {
        return;
      }

      if (action === "edit") {
        const entry = entries[index];
        editIndex = index;
        dateInput.value = entry.date;
        descInput.value = entry.description;
        amountInput.value = entry.amount;
        typeInput.value = entry.type;
        submitButton.textContent = "Save Entry";
        descInput.focus();
        return;
      }

      if (action === "delete") {
        entries.splice(index, 1);
        if (editIndex === index) {
          resetForm();
        } else if (editIndex !== null && index < editIndex) {
          editIndex -= 1;
        }
        saveEntries(entries);
        render(entries);
      }
    });

    setToday();
    setupVoiceInput();
    const initialEntries = loadEntries();
    render(initialEntries);
  </script>
</body>
</html>
